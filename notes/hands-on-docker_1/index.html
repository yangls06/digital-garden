<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Docker入门：step by step  为上手学习Docker，我参照阮一峰老师写的教程，step by step地动手实践。此文记录。
 参考  阮一峰：Docker入门教程
进一步实践，请移步：
  Docker进阶：step by step  一、环境配置的难题 软件开发最大的麻烦之一就是环境配置。每个人的机器的系统配置都不一样，包括操作系统、各种库与组件、环境变量等等。软件+运行环境，整体发布是解决这个问题的思路。Dockek是这种思路的实现。"><title>Docker入门</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://yangls06.github.io/digital-garden//icon.png><link href=https://yangls06.github.io/digital-garden/styles.708c2658f93e3a9d323a1f9fded8f4b2.min.css rel=stylesheet><link href=https://yangls06.github.io/digital-garden/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://yangls06.github.io/digital-garden/js/darkmode.aa0630d04550405b827df945275af6c3.min.js></script>
<script src=https://yangls06.github.io/digital-garden/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://yangls06.github.io/digital-garden/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://yangls06.github.io/digital-garden/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://yangls06.github.io/digital-garden/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://yangls06.github.io/digital-garden/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://yangls06.github.io/digital-garden/",fetchData=Promise.all([fetch("https://yangls06.github.io/digital-garden/indices/linkIndex.b483d0e748dd1aaa7075b414f1c96030.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://yangls06.github.io/digital-garden/indices/contentIndex.68251d876ee8d01ae2b5b3481b1461c4.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://yangls06.github.io/digital-garden",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://yangls06.github.io/digital-garden",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/yangls06.github.io\/digital-garden\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-GQ32FS7YEX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-GQ32FS7YEX",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://yangls06.github.io/digital-garden/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://yangls06.github.io/digital-garden/>🪴 无人之路</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Docker入门</h1><p class=meta>Last updated
Dec 14, 2022
<a href=https://github.com/yangls06/digital-garden/tree/hugo/content/notes/hands-on-docker_1.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://yangls06.github.io/digital-garden/tags/docker/>Docker</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#参考>参考</a></li><li><a href=#一环境配置的难题>一、环境配置的难题</a></li><li><a href=#二虚拟机>二、虚拟机</a></li><li><a href=#三linux容器>三、Linux容器</a></li><li><a href=#四docker是什么>四、Docker是什么？</a></li><li><a href=#五docker的用途>五、Docker的用途</a></li><li><a href=#六docker-的安装>六、Docker 的安装</a></li><li><a href=#七image-文件>七、image 文件</a></li><li><a href=#八实例hello-world>八、实例：hello world</a></li><li><a href=#九容器文件>九、容器文件</a></li><li><a href=#十dockerfile-文件>十、Dockerfile 文件</a></li><li><a href=#十一实例制作自己的-docker-容器>十一、实例：制作自己的 Docker 容器</a><ol><li></li><li><a href=#十二其他有用的命令>十二、其他有用的命令</a></li></ol></li></ol></nav></details></aside><a href=#docker入门step-by-step><h1 id=docker入门step-by-step><span class=hanchor arialabel=Anchor># </span>Docker入门：step by step</h1></a><blockquote><p>为上手学习Docker，我参照阮一峰老师写的教程，step by step地动手实践。此文记录。</p></blockquote><a href=#参考><h2 id=参考><span class=hanchor arialabel=Anchor># </span>参考</h2></a><p><a href=https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html rel=noopener>阮一峰：Docker入门教程</a></p><p>进一步实践，请移步：</p><ul><li><a href=/digital-garden/notes/hands-on-docker_2/ rel=noopener class=internal-link data-src=/digital-garden/notes/hands-on-docker_2/>Docker进阶：step by step</a></li></ul><a href=#一环境配置的难题><h2 id=一环境配置的难题><span class=hanchor arialabel=Anchor># </span>一、环境配置的难题</h2></a><p>软件开发最大的麻烦之一就是环境配置。每个人的机器的系统配置都不一样，包括操作系统、各种库与组件、环境变量等等。软件+运行环境，整体发布是解决这个问题的思路。Dockek是这种思路的实现。</p><a href=#二虚拟机><h2 id=二虚拟机><span class=hanchor arialabel=Anchor># </span>二、虚拟机</h2></a><p>在Docker之前，虚拟机是一种解决方案。但其缺点明显，包括：</p><ul><li><p><strong>资源占用多</strong>。虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p></li><li><p><strong>冗余步骤多</strong>。虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p></li><li><p>**启动慢。**启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p></li></ul><a href=#三linux容器><h2 id=三linux容器><span class=hanchor arialabel=Anchor># </span>三、Linux容器</h2></a><p>Linux容器（Linux Container， LXC）是另一种虚拟化技术。</p><p>**Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。**或者说，在正常进程的外面套了一个
<a href=https://opensource.com/article/18/1/history-low-level-container-runtimes rel=noopener>保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>由于容器是进程级别的，相比虚拟机有很多优势。</p><ul><li><p>**启动快。**容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p></li><li><p>**资源占用少。**容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p></li><li><p>**体积小。**容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p></li></ul><p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><a href=#四docker是什么><h2 id=四docker是什么><span class=hanchor arialabel=Anchor># </span>四、Docker是什么？</h2></a><p>**Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。**它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><a href=#五docker的用途><h2 id=五docker的用途><span class=hanchor arialabel=Anchor># </span>五、Docker的用途</h2></a><p>Docker 的主要用途，目前有三大类。</p><ul><li><p>**提供一次性的环境。**比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p></li><li><p>**提供弹性的云服务。**因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p></li><li><p>**组建微服务架构。**通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p></li></ul><a href=#六docker-的安装><h2 id=六docker-的安装><span class=hanchor arialabel=Anchor># </span>六、Docker 的安装</h2></a><p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。</p><p>Docker CE 的安装请参考官方文档。</p><blockquote><ul><li><p><a href=https://docs.docker.com/docker-for-mac/install/ rel=noopener>Mac</a></p></li><li><p><a href=https://docs.docker.com/docker-for-windows/install/ rel=noopener>Windows</a></p></li><li><p><a href=https://docs.docker.com/install/linux/docker-ce/ubuntu/ rel=noopener>Ubuntu</a></p></li><li><p>。。。</p></li></ul></blockquote><p>安装完成后，运行下面的命令，验证是否安装成功。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker version
</span></span><span class=line><span class=cl><span class=c1># 或者</span>
</span></span><span class=line><span class=cl>$ docker info
</span></span></code></pre></td></tr></table></div></div><p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组（
<a href=https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user rel=noopener>官方文档</a>）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>sudo usermod -aG docker <span class=nv>$USER</span>
</span></span><span class=line><span class=cl><span class=c1># 需要log out 才能生效，不让docker info命令的Sever部分会报错</span>
</span></span><span class=line><span class=cl><span class=c1># 详情见：https://docs.docker.com/engine/install/linux-postinstall/</span>
</span></span></code></pre></td></tr></table></div></div><p>Docker 是服务器&mdash;-客户端架构。命令行运行<code>docker</code>命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（
<a href=https://docs.docker.com/config/daemon/systemd/ rel=noopener>官方文档</a>）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1># service 命令的用法</span>
</span></span><span class=line><span class=cl>$ sudo service docker start
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># systemctl 命令的用法</span>
</span></span><span class=line><span class=cl>$ sudo systemctl start docker
</span></span></code></pre></td></tr></table></div></div><p>安装成功后，可以</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run hello-world
</span></span></code></pre></td></tr></table></div></div><p><img src=https://happy3-data.oss-cn-hangzhou.aliyuncs.com/content-images/image-20221214173436747.png width=auto alt=image-20221214173436747></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>docker run -it ubuntu bash
</span></span></code></pre></td></tr></table></div></div><img src=https://happy3-data.oss-cn-hangzhou.aliyuncs.com/content-images/dcc8d661-5b86-4c2b-9cc3-e50e6a34719e.jpeg alt=dcc8d661-5b86-4c2b-9cc3-e50e6a34719e style=zoom:50%><p>其中下载的image大小是30MB</p><blockquote><p>$ docker image ls</p><p>REPOSITORY TAG IMAGE ID CREATED SIZE</p><p>ubuntu latest df5de72bdb3b 2 weeks ago 77.8MB</p><p>hello-world latest feb5d9fea6a5 11 months ago 13.3kB</p></blockquote><a href=#七image-文件><h2 id=七image-文件><span class=hanchor arialabel=Anchor># </span>七、image 文件</h2></a><p>**Docker 把应用程序及其依赖，打包在 image 文件里面。**只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库
<a href=https://hub.docker.com/ rel=noopener>Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><a href=#八实例hello-world><h2 id=八实例hello-world><span class=hanchor arialabel=Anchor># </span>八、实例：hello world</h2></a><p>下面，我们通过最简单的 image 文件"
<a href=https://hub.docker.com/r/library/hello-world/ rel=noopener>hello world"</a>，感受一下 Docker。</p><p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在
<a href=https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html rel=noopener>下一篇文章</a>的第一节。有需要的朋友，可以先看一下。</p><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker image pull library/hello-world
</span></span></code></pre></td></tr></table></div></div><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<code>library</code>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker image pull hello-world
</span></span></code></pre></td></tr></table></div></div><p>抓取成功以后，就可以在本机看到这个 image 文件了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker image ls
</span></span></code></pre></td></tr></table></div></div><p>现在，运行这个 image 文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker container run hello-world
</span></span></code></pre></td></tr></table></div></div><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>如果运行成功，你会在屏幕上读到下面的输出。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker container run hello-world
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Hello from Docker!
</span></span><span class=line><span class=cl>This message shows that your installation appears to be working correctly.... ...
</span></span></code></pre></td></tr></table></div></div><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker container run -it ubuntu bash
</span></span></code></pre></td></tr></table></div></div><p>对于那些不会自动终止的容器，必须使用<code>docker container kill</code> 命令手动终止。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker container <span class=nb>kill</span> <span class=o>[</span>containID<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## 如下例子</span>
</span></span><span class=line><span class=cl>$ docker container ls
</span></span><span class=line><span class=cl>CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS          PORTS     NAMES
</span></span><span class=line><span class=cl>f45ef5fcc683   ubuntu    <span class=s2>&#34;bash&#34;</span>    <span class=m>21</span> minutes ago   Up <span class=m>21</span> minutes             charming_montalcini
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># happy3 @ happy3-HX in ~ [15:46:39] </span>
</span></span><span class=line><span class=cl>$ docker <span class=nb>kill</span> f45ef5fcc683
</span></span><span class=line><span class=cl>f45ef5fcc683
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># happy3 @ happy3-HX in ~ [15:46:47] </span>
</span></span><span class=line><span class=cl>$ docker container ls     
</span></span><span class=line><span class=cl>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># happy3 @ happy3-HX in ~ [15:46:54] </span>
</span></span><span class=line><span class=cl>$ 
</span></span></code></pre></td></tr></table></div></div><a href=#九容器文件><h2 id=九容器文件><span class=hanchor arialabel=Anchor># </span>九、容器文件</h2></a><p>**image 文件生成的容器实例，本身也是一个文件，称为容器文件。**也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<code>docker container rm</code>命令删除。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker container rm <span class=o>[</span>containerID<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><a href=#十dockerfile-文件><h2 id=十dockerfile-文件><span class=hanchor arialabel=Anchor># </span>十、Dockerfile 文件</h2></a><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p><p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p><p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p><a href=#十一实例制作自己的-docker-容器><h2 id=十一实例制作自己的-docker-容器><span class=hanchor arialabel=Anchor># </span>十一、实例：制作自己的 Docker 容器</h2></a><p>下面我以
<a href=https://www.ruanyifeng.com/blog/2017/08/koa.html rel=noopener>koa-demos</a> 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p><p>作为准备工作，请先
<a href=https://github.com/ruanyf/koa-demos/archive/master.zip rel=noopener>下载源码</a>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ git clone https://github.com/ruanyf/koa-demos.git
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> koa-demos
</span></span></code></pre></td></tr></table></div></div><a href=#111-编写-dockerfile-文件><h4 id=111-编写-dockerfile-文件><span class=hanchor arialabel=Anchor># </span>11.1 编写 Dockerfile 文件</h4></a><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的
<a href=https://github.com/ruanyf/koa-demos/blob/master/.dockerignore rel=noopener>内i容</a>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>.git
</span></span><span class=line><span class=cl>node_modules
</span></span><span class=line><span class=cl>npm-debug.log
</span></span></code></pre></td></tr></table></div></div><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的
<a href=https://github.com/ruanyf/koa-demos/blob/master/Dockerfile rel=noopener>内容</a>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>FROM node:8.4
</span></span><span class=line><span class=cl>COPY . /app
</span></span><span class=line><span class=cl>WORKDIR /app
</span></span><span class=line><span class=cl>RUN npm install --registry<span class=o>=</span>https://registry.npm.taobao.org
</span></span><span class=line><span class=cl>EXPOSE <span class=m>3000</span>
</span></span></code></pre></td></tr></table></div></div><p>上面代码一共五行，含义如下。</p><blockquote><ul><li><p><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</p></li><li><p><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</p></li><li><p><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</p></li><li><p><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</p></li><li><p><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</p></li></ul></blockquote><a href=#112-创建-image-文件><h4 id=112-创建-image-文件><span class=hanchor arialabel=Anchor># </span>11.2 创建 image 文件</h4></a><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker image build -t koa-demo .
</span></span><span class=line><span class=cl><span class=c1># 或者</span>
</span></span><span class=line><span class=cl>$ docker image build -t koa-demo:0.0.1 .
</span></span></code></pre></td></tr></table></div></div><p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p><p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker image ls
</span></span></code></pre></td></tr></table></div></div><img src=https://happy3-data.oss-cn-hangzhou.aliyuncs.com/content-images/2c593f99-bc20-45bf-b5df-01300fa5ef4d.jpeg alt=2c593f99-bc20-45bf-b5df-01300fa5ef4d style=zoom:50%>
<a href=#113-生成容器><h4 id=113-生成容器><span class=hanchor arialabel=Anchor># </span>11.3 生成容器</h4></a><p><code>docker container run</code>命令会从 image 文件生成容器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker container run -p 8000:3000 -it koa-demo /bin/bash
</span></span><span class=line><span class=cl><span class=c1># 或者</span>
</span></span><span class=line><span class=cl>$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash
</span></span></code></pre></td></tr></table></div></div><p>上面命令的各个参数含义如下：</p><blockquote><ul><li><p><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</p></li><li><p><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</p></li><li><p><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</p></li><li><p><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</p></li></ul></blockquote><p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>root@66d80f4aaf1e:/app#
</span></span></code></pre></td></tr></table></div></div><p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>root@66d80f4aaf1e:/app# node demos/01.js
</span></span></code></pre></td></tr></table></div></div><p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 http://127.0.0.1:8000，网页显示"Not Found"，这是因为这个
<a href=https://github.com/ruanyf/koa-demos/blob/master/demos/01.js rel=noopener>demo</a> 没有写路由。</p><p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1># 在本机的另一个终端窗口，查出容器的 ID</span>
</span></span><span class=line><span class=cl>$ docker container ls
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 停止指定的容器运行</span>
</span></span><span class=line><span class=cl>$ docker container <span class=nb>kill</span> <span class=o>[</span>containerID<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl><span class=c1># 查出容器的 ID</span>
</span></span><span class=line><span class=cl>$ docker container ls --all
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 删除指定的容器文件</span>
</span></span><span class=line><span class=cl>$ docker container rm <span class=o>[</span>containerID<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash
</span></span></code></pre></td></tr></table></div></div><a href=#114-cmd-命令><h4 id=114-cmd-命令><span class=hanchor arialabel=Anchor># </span>11.4 CMD 命令</h4></a><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>FROM node:8.4
</span></span><span class=line><span class=cl>COPY . /app
</span></span><span class=line><span class=cl>WORKDIR /app
</span></span><span class=line><span class=cl>RUN npm install --registry<span class=o>=</span>https://registry.npm.taobao.org
</span></span><span class=line><span class=cl>EXPOSE <span class=m>3000</span>
</span></span><span class=line><span class=cl>CMD node demos/01.js
</span></span></code></pre></td></tr></table></div></div><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1
</span></span></code></pre></td></tr></table></div></div><a href=#115-发布-image-文件><h4 id=115-发布-image-文件><span class=hanchor arialabel=Anchor># </span>11.5 发布 image 文件</h4></a><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p><p>首先，去
<a href=https://hub.docker.com/ rel=noopener>hub.docker.com</a> 或
<a href=https://cloud.docker.com/ rel=noopener>cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker login
</span></span></code></pre></td></tr></table></div></div><p>接着，为本地的 image 标注用户名和版本。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker image tag <span class=o>[</span>imageName<span class=o>]</span> <span class=o>[</span>username<span class=o>]</span>/<span class=o>[</span>repository<span class=o>]</span>:<span class=o>[</span>tag<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=c1># 实例</span>
</span></span><span class=line><span class=cl>$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1
</span></span></code></pre></td></tr></table></div></div><p>也可以不标注用户名，重新构建一下 image 文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker image build -t <span class=o>[</span>username<span class=o>]</span>/<span class=o>[</span>repository<span class=o>]</span>:<span class=o>[</span>tag<span class=o>]</span> .
</span></span></code></pre></td></tr></table></div></div><p>最后，发布 image 文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker image push <span class=o>[</span>username<span class=o>]</span>/<span class=o>[</span>repository<span class=o>]</span>:<span class=o>[</span>tag<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p><a href=#十二其他有用的命令><h3 id=十二其他有用的命令><span class=hanchor arialabel=Anchor># </span>十二、其他有用的命令</h3></a><p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p><p><strong>（1）docker container start</strong></p><p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker container start <span class=o>[</span>containerID<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>（2）docker container stop</strong></p><p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker container stop <span class=o>[</span>containerID<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p><p><strong>（3）docker container logs</strong></p><p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker container logs <span class=o>[</span>containerID<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>（4）docker container exec</strong></p><p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker container <span class=nb>exec</span> -it <span class=o>[</span>containerID<span class=o>]</span> /bin/bash
</span></span></code></pre></td></tr></table></div></div><p><strong>（5）docker container cp</strong></p><p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>$ docker container cp <span class=o>[</span>containID<span class=o>]</span>:<span class=o>[</span>/path/to/file<span class=o>]</span> .
</span></span></code></pre></td></tr></table></div></div><p>Done!</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/digital-garden/notes/devops/ data-ctx="Docker入门：step by step" data-src=/notes/devops class=internal-link>DevOps</a></li><li><a href=/digital-garden/notes/hands-on-docker_2/ data-ctx="Docker入门：step by step" data-src=/notes/hands-on-docker_2 class=internal-link>Docker进阶</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://yangls06.github.io/digital-garden/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by yangls06 using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2022</p><ul><li><a href=https://yangls06.github.io/digital-garden/>Home</a></li><li><a href=https://github.com/yangls06>Github</a></li></ul></footer></div></div></body></html>